name: CPP Module Tests

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test-cpp-modules:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
    
    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y build-essential wget
        sudo wget https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -O /usr/bin/yq
        sudo chmod +x /usr/bin/yq
    
    - name: Discover and test all exercises
      run: |
        #!/bin/bash
        set -e
        
        total_passed=0
        total_failed=0
        
        # Find all exercises with test YAML files
        echo "Searching for exercises..."
        exercises=$(find . -name "test_*.yaml" | sort)
        
        if [ -z "$exercises" ]; then
          echo "No test files found!"
          exit 1
        fi
        
        echo "Found exercises to test:"
        echo "$exercises"
        echo "=========================================="
        
        for test_file in $exercises; do
          ex_dir=$(dirname "$test_file")
          test_name=$(basename "$test_file")
          
          echo ""
          echo "=========================================="
          echo "Testing: $ex_dir"
          echo "Test file: $test_name"
          echo "=========================================="
          
          # Check if Makefile exists
          if [ ! -f "$ex_dir/Makefile" ]; then
            echo "No Makefile found in $ex_dir, skipping..."
            continue
          fi
          
          # Build
          echo "Building..."
          cd "$ex_dir"
          if ! make > /dev/null 2>&1; then
            echo "✗ Build failed for $ex_dir"
            ((total_failed++))
            cd - > /dev/null
            continue
          fi
          echo "Build successful!"
          echo "------------------------------------------"
          
          # Check test type and run tests
          if yq e '.test_cases' "$test_name" > /dev/null 2>&1; then
            # Simple command-line tests (ex00)
            test_count=$(yq e '.test_cases | length' "$test_name")
            passed=0
            failed=0
            
            for ((i=0; i<test_count; i++)); do
              test_num=$((i+1))
              name=$(yq e ".test_cases[$i].name" "$test_name")
              command=$(yq e ".test_cases[$i].command" "$test_name")
              expected=$(yq e ".test_cases[$i].expected_output" "$test_name")
              expected_exit=$(yq e ".test_cases[$i].exit_code // 0" "$test_name")
              
              # Run command
              output=$(eval "$command" 2>&1 || true)
              exit_code=$?
              
              # Compare results
              if [ "$output" = "$expected" ] && [ "$exit_code" = "$expected_exit" ]; then
                echo "✓ Test $test_num passed: $name"
                ((passed++))
              else
                echo "✗ Test $test_num failed: $name"
                echo "  Expected: '$expected'"
                echo "  Got: '$output'"
                echo "  Expected exit: $expected_exit, Got: $exit_code"
                ((failed++))
              fi
            done
            
            echo "------------------------------------------"
            echo "Results: $passed passed, $failed failed"
            total_passed=$((total_passed + passed))
            total_failed=$((total_failed + failed))
            
          elif yq e '.test_scenarios' "$test_name" > /dev/null 2>&1; then
            # Interactive tests (ex01)
            test_count=$(yq e '.test_scenarios | length' "$test_name")
            passed=0
            failed=0
            
            # Find executable
            executable=$(find . -maxdepth 1 -type f -executable ! -name "*.sh" | head -1)
            if [ -z "$executable" ]; then
              echo "✗ No executable found"
              ((total_failed++))
              cd - > /dev/null
              continue
            fi
            
            for ((i=0; i<test_count; i++)); do
              test_num=$((i+1))
              name=$(yq e ".test_scenarios[$i].name" "$test_name")
              description=$(yq e ".test_scenarios[$i].description" "$test_name")
              
              echo "Test $test_num: $name"
              echo "  Description: $description"
              
              # Get input sequence
              input_count=$(yq e ".test_scenarios[$i].input_sequence | length" "$test_name")
              input_data=""
              for ((j=0; j<input_count; j++)); do
                line=$(yq e ".test_scenarios[$i].input_sequence[$j]" "$test_name")
                input_data="${input_data}${line}"$'\n'
              done
              
              # Run with timeout
              if timeout 5s bash -c "echo '$input_data' | $executable" > /dev/null 2>&1; then
                echo "✓ Test $test_num passed: $name"
                ((passed++))
              else
                exit_code=$?
                if [ $exit_code -eq 124 ]; then
                  echo "✗ Test $test_num failed: $name (timeout)"
                else
                  echo "✗ Test $test_num failed: $name (exit code: $exit_code)"
                fi
                ((failed++))
              fi
            done
            
            echo "------------------------------------------"
            echo "Results: $passed passed, $failed failed"
            total_passed=$((total_passed + passed))
            total_failed=$((total_failed + failed))
          fi
          
          # Cleanup
          make fclean > /dev/null 2>&1 || true
          cd - > /dev/null
        done
        
        echo ""
        echo "=========================================="
        echo "OVERALL RESULTS: $total_passed passed, $total_failed failed"
        echo "=========================================="
        
        if [ $total_failed -gt 0 ]; then
          exit 1
        fi
